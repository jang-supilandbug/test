

[주제3]
예약 처리 프로세스와 데이터 모델에서 발생하고 있는 동시성 이슈의 해결 방안 제시

<전제 조건>
-

[예상 문제]
문1) 다수의 사용자가 다수의 인벤토리 예약을 하기 위한 데이터 모델의 문제점을 확인하고, 해결을 위한
      방안을 제시하시오.
 <제약 조건>
예약 처리 프로세스는 Async 한 방식으로 구현 되어야 한다

문2) 다수의 사용자가 하나의 인벤토리 예약을 하려고 한다, 데이터 모델의 문제점을 확인하고 해결을 위한
      방안을 제시하시오.
 <제약 조건>
예약 처리 프로세스는 Async 한 방식으로 구현 되어야 한다     

문3) 예약된 서비스에 대해 취소 프로세스를 구성하시오  
 
ChatGPT
동시성 이슈를 해결하기 위한 예약 처리 프로세스와 데이터 모델에 대해 논의하겠습니다.

문1) 다수의 사용자가 다수의 인벤토리 예약을 하기 위한 데이터 모델의 문제점 확인 및 해결 방안
문제점:
다수의 사용자가 동시에 여러 인벤토리를 예약할 때 동시성 문제가 발생할 수 있습니다. 예를 들어, 두 사용자가 동시에 같은 인벤토리 항목을 예약하려고 할 때, 각 사용자가 인벤토리가 아직 남아 있다고 판단해 예약을 진행할 수 있습니다. 이로 인해 데이터 무결성이 깨지거나 예약이 중복되는 문제가 발생할 수 있습니다.

해결 방안:
낙관적 락(Optimistic Locking): 데이터베이스에서 버전 번호를 사용하여 레코드를 업데이트할 때 충돌을 감지합니다. 예약을 수행하기 전에 인벤토리의 버전 번호를 읽고, 예약 시도 시에도 해당 버전 번호를 다시 확인합니다. 만약 버전 번호가 다르다면 다른 사용자가 먼저 예약을 완료한 것이므로 현재 트랜잭션을 롤백하고 다시 시도할 수 있습니다.

비관적 락(Pessimistic Locking): 인벤토리 레코드에 대해 예약 시도 시점에서 데이터베이스에 락을 걸어 다른 트랜잭션이 해당 인벤토리 레코드를 수정하지 못하도록 합니다. 그러나 이는 성능 저하를 초래할 수 있기 때문에 사용 시 신중해야 합니다.

큐 기반 처리(Queue-based Processing): 예약 요청을 큐에 쌓아 두고 순차적으로 처리하는 방식입니다. 각 예약 요청이 순서대로 처리되므로 동시성 이슈를 피할 수 있습니다.

데이터 모델링 개선: 인벤토리 테이블에 남은 수량 필드만 두는 대신, 예약이 성공적으로 완료된 상태를 기록하는 별도의 예약 테이블을 두어 이력을 관리할 수 있습니다. 이를 통해 동시성 이슈를 보다 잘 다룰 수 있습니다.

문2) 다수의 사용자가 하나의 인벤토리를 예약하려고 할 때 문제점 확인 및 해결 방안
문제점:
여러 사용자가 동일한 인벤토리 항목을 동시에 예약하려고 할 때, 재고 수량이 남아 있지 않더라도 예약이 이루어지는 문제가 발생할 수 있습니다. 이는 시스템의 동시성 처리 능력에 따라 중복 예약이 발생할 수 있습니다.

해결 방안:
Atomic Operation 사용: 예약 프로세스를 Atomic하게 처리하여 동시성 문제를 해결할 수 있습니다. 예를 들어, 데이터베이스의 트랜잭션을 사용하여 하나의 트랜잭션에서 인벤토리 확인, 예약, 업데이트를 모두 처리하면 중복 예약을 방지할 수 있습니다.

Optimistic Locking 적용: 앞서 설명한 것처럼 버전 번호를 활용해 예약 시점에서 재고 수량이 변동되었는지 확인하고, 변동된 경우 재시도하도록 합니다.

비관적 락(Pessimistic Locking): 특정 인벤토리에 대한 예약이 진행될 때, 다른 사용자가 동시에 해당 인벤토리를 예약하려는 시도를 방지하기 위해 락을 사용할 수 있습니다. 그러나 이는 높은 동시성 상황에서는 성능에 영향을 미칠 수 있습니다.

예약 큐 시스템: 예약 요청을 큐에 넣어 순차적으로 처리하는 방식입니다. 큐에 요청이 쌓여 순차적으로 처리되기 때문에 동시에 하나의 인벤토리를 여러 사용자가 예약하려고 할 때 발생하는 충돌을 피할 수 있습니다.

문3) 예약된 서비스에 대한 취소 프로세스 구성
예약된 서비스를 취소하는 프로세스는 예약의 상태를 관리하는 별도의 테이블이나 컬럼을 통해 이루어질 수 있습니다.

예약 상태 업데이트: 예약이 취소되면 해당 예약의 상태를 "취소"로 업데이트합니다. 이때, 취소 가능 여부(예: 취소 기한이 지났는지 여부)를 먼저 확인한 후 상태를 업데이트해야 합니다.

인벤토리 회복: 예약 취소 시점에 인벤토리에서 차감된 수량을 다시 회복시켜야 합니다. 이는 원자적 트랜잭션으로 처리되어야 하며, 취소와 인벤토리 회복이 동시에 이루어져야 합니다.

비동기 처리: 예약 취소 요청을 비동기로 처리하는 경우, 큐를 사용해 취소 요청을 처리하도록 할 수 있습니다. 큐에 취소 요청이 쌓이면 순차적으로 처리하여 취소 작업과 인벤토리 회복 작업이 완료됩니다.

로그 기록: 모든 취소 요청은 로그로 기록되어 추후 문제가 발생할 경우 원인을 추적할 수 있도록 합니다.

이러한 방안들은 시스템이 더 높은 동시성을 지원하고 데이터 무결성을 유지할 수 있도록 도와줍니다.









